{"ast":null,"code":"export default function evolvingWordsSketch(p) {\n  // Global variables\n  var positions;\n  var step = 0;\n  var canvas; //\n  // Calculates the particles trajectories\n  //\n\n  let calculateTrajectories = function (text, nParticles) {\n    var words, limits, trajectories, nSteps, i; // Split the text into words\n\n    words = p.splitTokens(text, \" \"); // Calculate the words limits\n\n    limits = [];\n\n    for (i = 0; i < words.length; i++) {\n      limits[i] = wordLimits(words[i]);\n    } // Calculate the particle trajectories\n\n\n    trajectories = [];\n    nSteps = 80;\n\n    for (i = 0; i < nParticles; i++) {\n      trajectories[i] = trajectory(limits, nSteps);\n    }\n\n    return trajectories;\n  }; //\n  // Calculates the word limits\n  //\n\n\n  let wordLimits = function (word) {\n    var textSize, limits, x, y, dx, dy, px, py, pixelDensity, pixelDensitySq, isLimit; // Paint the background\n\n    p.background(0); // Paint the text\n\n    textSize = 0.25 * p.width;\n    p.push();\n    p.textFont(\"Helvetica\");\n    p.textAlign(p.CENTER);\n    p.textSize(textSize);\n    p.textStyle(p.BOLD);\n    p.noStroke();\n    p.fill(255);\n    p.text(word, 0.5 * p.width, 0.5 * p.height + 0.25 * textSize);\n    p.pop(); // Calculate the limits\n\n    limits = [];\n    pixelDensity = p.displayDensity();\n    pixelDensitySq = pixelDensity * pixelDensity;\n    p.loadPixels();\n\n    for (y = 0; y < p.height; y++) {\n      for (x = 0; x < p.width; x++) {\n        isLimit = false;\n\n        if (p.pixels[4 * (x * pixelDensity + y * p.width * pixelDensitySq)] === 255) {\n          // Check the nearby pixels for a color change\n          for (dx = -1; dx <= 1; dx++) {\n            for (dy = -1; dy <= 1; dy++) {\n              // Don't calculate more if we already know that it's\n              // a limit\n              if (!isLimit) {\n                px = x + dx;\n                py = y + dy;\n\n                if (px >= 0 && px < p.width && py >= 0 && py < p.height) {\n                  if (p.pixels[4 * (px * pixelDensity + py * p.width * pixelDensitySq)] !== 255) {\n                    isLimit = true;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (isLimit) {\n          limits.push(new toxi.geom.Vec2D(x, y));\n        }\n      }\n    }\n\n    p.updatePixels(); // Clean the canvas\n\n    p.background(0);\n    return limits;\n  }; //\n  // Calculates the particle trajectory\n  //\n\n\n  let trajectory = function (limits, steps) {\n    var positionInWords, i, spline, center; // Calculate the particle position in the different words\n\n    positionInWords = [];\n\n    for (i = 0; i < limits.length; i++) {\n      positionInWords[i] = limits[i][Math.floor(limits[i].length * Math.random())];\n    } // Add the spline points\n\n\n    spline = new toxi.geom.Spline2D();\n    spline.setTightness(0.2);\n    minDim = Math.min(p.width, p.height);\n    maxDim = Math.max(p.width, p.height);\n    center = new toxi.geom.Vec2D(0.5 * p.width, 0.5 * p.height);\n\n    for (i = 0; i < positionInWords.length - 1; i++) {\n      spline.add(positionInWords[i]);\n      spline.add(randomVector(0, 15).add(center));\n      spline.add(randomVector(0, 0.2 * minDim).add(positionInWords[i + 1]));\n      spline.add(randomVector(0, 0.02 * minDim).add(positionInWords[i + 1]));\n    }\n\n    spline.add(positionInWords[positionInWords.length - 1]);\n    spline.add(randomVector(0, 15).add(center));\n    spline.add(center);\n    spline.add(randomVector(maxDim, 3 * maxDim).add(center));\n    return spline.computeVertices(steps);\n  }; //\n  // Returns a random vector within the given radius limits\n  //\n\n\n  let randomVector = function (minRadius, maxRadius) {\n    var angle = p.TWO_PI * Math.random();\n    var radius = minRadius + (maxRadius - minRadius) * p.randomGaussian();\n    return new toxi.geom.Vec2D(radius * Math.cos(angle), radius * Math.sin(angle));\n  }; // Creates and adds the canvas element\n\n\n  function addCanvas(canvasWidth, canvasHeight) {\n    var referenceElement, maxCanvasWidth, canvas; // Calculate the canvas dimensions\n\n    referenceElement = document.getElementById(\"widthRef\");\n    maxCanvasWidth = referenceElement.clientWidth - 1;\n\n    if (canvasWidth > maxCanvasWidth) {\n      canvasHeight = maxCanvasWidth * canvasHeight / canvasWidth;\n      canvasWidth = maxCanvasWidth;\n    } // Create the canvas\n\n\n    canvas = p.createCanvas(canvasWidth, canvasHeight); // Resize the canvas if necessary\n\n    maxCanvasWidth = referenceElement.clientWidth - 1;\n\n    if (canvasWidth > maxCanvasWidth) {\n      p.resizeCanvas(maxCanvasWidth, maxCanvasWidth * canvasHeight / canvasWidth, true);\n    }\n\n    return canvas;\n  }\n\n  p.windowResized = function () {\n    p.resizeCanvas(p.windowWidth, p.windowHeight);\n  }; // Initial setup\n\n\n  p.setup = function () {\n    // Add the canvas element\n    //addCanvas(600, 400);\n    canvas = p.createCanvas(p.windowWidth, p.windowHeight);\n    canvas.position(0, 0);\n    canvas.style('z-index', '-1'); // Calculate the trajectory positions for every particle\n\n    positions = calculateTrajectories(\"This is not a LOVE story\", 2 * p.width);\n  }; // Execute the sketch\n\n\n  p.draw = function () {\n    // Clean the canvas\n    p.background(0, 100); // Paint the trajectories step by step\n\n    if (step < positions[0].length) {\n      p.noStroke();\n      p.fill(0, 150, 200, 100); // Draw all the particles\n\n      for (var i = 0; i < positions.length; i++) {\n        p.ellipse(positions[i][step].x, positions[i][step].y, 5, 5);\n      }\n    } else if (step > positions[0].length + 20) {\n      // Stop the sketch\n      p.noLoop();\n    }\n\n    step++;\n  };\n}\n;","map":{"version":3,"sources":["C:/Users/GAURAV C G/Desktop/Work/intra_mail/src/sketches/evolvingWords.js"],"names":["evolvingWordsSketch","p","positions","step","canvas","calculateTrajectories","text","nParticles","words","limits","trajectories","nSteps","i","splitTokens","length","wordLimits","trajectory","word","textSize","x","y","dx","dy","px","py","pixelDensity","pixelDensitySq","isLimit","background","width","push","textFont","textAlign","CENTER","textStyle","BOLD","noStroke","fill","height","pop","displayDensity","loadPixels","pixels","toxi","geom","Vec2D","updatePixels","steps","positionInWords","spline","center","Math","floor","random","Spline2D","setTightness","minDim","min","maxDim","max","add","randomVector","computeVertices","minRadius","maxRadius","angle","TWO_PI","radius","randomGaussian","cos","sin","addCanvas","canvasWidth","canvasHeight","referenceElement","maxCanvasWidth","document","getElementById","clientWidth","createCanvas","resizeCanvas","windowResized","windowWidth","windowHeight","setup","position","style","draw","ellipse","noLoop"],"mappings":"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","sourcesContent":["export default function evolvingWordsSketch(p){\r\n\t// Global variables\r\n\tvar positions;\r\n    var step = 0;\r\n    var canvas;\r\n\r\n    //\r\n\t// Calculates the particles trajectories\r\n\t//\r\n\tlet calculateTrajectories = function(text, nParticles) {\r\n\t\tvar words, limits, trajectories, nSteps, i;\r\n\r\n\t\t// Split the text into words\r\n\t\twords = p.splitTokens(text, \" \");\r\n\r\n\t\t// Calculate the words limits\r\n\t\tlimits = [];\r\n\r\n\t\tfor (i = 0; i < words.length; i++) {\r\n\t\t\tlimits[i] = wordLimits(words[i]);\r\n\t\t}\r\n\r\n\t\t// Calculate the particle trajectories\r\n\t\ttrajectories = [];\r\n\t\tnSteps = 80;\r\n\r\n\t\tfor (i = 0; i < nParticles; i++) {\r\n\t\t\ttrajectories[i] = trajectory(limits, nSteps);\r\n\t\t}\r\n\r\n\t\treturn trajectories;\r\n\t};\r\n\r\n\t//\r\n\t// Calculates the word limits\r\n\t//\r\n\tlet wordLimits = function(word) {\r\n\t\tvar textSize, limits, x, y, dx, dy, px, py, pixelDensity, pixelDensitySq, isLimit;\r\n\r\n\t\t// Paint the background\r\n\t\tp.background(0);\r\n\r\n\t\t// Paint the text\r\n\t\ttextSize = 0.25 * p.width;\r\n\t\tp.push();\r\n\t\tp.textFont(\"Helvetica\");\r\n\t\tp.textAlign(p.CENTER);\r\n\t\tp.textSize(textSize);\r\n\t\tp.textStyle(p.BOLD);\r\n\t\tp.noStroke();\r\n\t\tp.fill(255);\r\n\t\tp.text(word, 0.5 * p.width, 0.5 * p.height + 0.25 * textSize);\r\n\t\tp.pop();\r\n\r\n\t\t// Calculate the limits\r\n\t\tlimits = [];\r\n\t\tpixelDensity = p.displayDensity();\r\n\t\tpixelDensitySq = pixelDensity * pixelDensity;\r\n\r\n\t\tp.loadPixels();\r\n\r\n\t\tfor (y = 0; y < p.height; y++) {\r\n\t\t\tfor (x = 0; x < p.width; x++) {\r\n\t\t\t\tisLimit = false;\r\n\r\n\t\t\t\tif (p.pixels[4 * (x * pixelDensity + y * p.width * pixelDensitySq)] === 255) {\r\n\t\t\t\t\t// Check the nearby pixels for a color change\r\n\t\t\t\t\tfor (dx = -1; dx <= 1; dx++) {\r\n\t\t\t\t\t\tfor (dy = -1; dy <= 1; dy++) {\r\n\t\t\t\t\t\t\t// Don't calculate more if we already know that it's\r\n\t\t\t\t\t\t\t// a limit\r\n\t\t\t\t\t\t\tif (!isLimit) {\r\n\t\t\t\t\t\t\t\tpx = x + dx;\r\n\t\t\t\t\t\t\t\tpy = y + dy;\r\n\r\n\t\t\t\t\t\t\t\tif (px >= 0 && px < p.width && py >= 0 && py < p.height) {\r\n\t\t\t\t\t\t\t\t\tif (p.pixels[4 * (px * pixelDensity + py * p.width * pixelDensitySq)] !== 255) {\r\n\t\t\t\t\t\t\t\t\t\tisLimit = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isLimit) {\r\n\t\t\t\t\tlimits.push(new toxi.geom.Vec2D(x, y));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tp.updatePixels();\r\n\r\n\t\t// Clean the canvas\r\n\t\tp.background(0);\r\n\r\n\t\treturn limits;\r\n\t};\r\n\r\n\t//\r\n\t// Calculates the particle trajectory\r\n\t//\r\n\tlet trajectory = function(limits, steps) {\r\n\t\tvar positionInWords, i, spline, center;\r\n\r\n\t\t// Calculate the particle position in the different words\r\n\t\tpositionInWords = [];\r\n\r\n\t\tfor (i = 0; i < limits.length; i++) {\r\n\t\t\tpositionInWords[i] = limits[i][Math.floor(limits[i].length * Math.random())];\r\n\t\t}\r\n\r\n\t\t// Add the spline points\r\n\t\tspline = new toxi.geom.Spline2D();\r\n\t\tspline.setTightness(0.2);\r\n\t\tminDim = Math.min(p.width, p.height);\r\n\t\tmaxDim = Math.max(p.width, p.height);\r\n\t\tcenter = new toxi.geom.Vec2D(0.5 * p.width, 0.5 * p.height);\r\n\r\n\t\tfor (i = 0; i < positionInWords.length - 1; i++) {\r\n\t\t\tspline.add(positionInWords[i]);\r\n\t\t\tspline.add(randomVector(0, 15).add(center));\r\n\t\t\tspline.add(randomVector(0, 0.2 * minDim).add(positionInWords[i + 1]));\r\n\t\t\tspline.add(randomVector(0, 0.02 * minDim).add(positionInWords[i + 1]));\r\n\t\t}\r\n\r\n\t\tspline.add(positionInWords[positionInWords.length - 1]);\r\n\t\tspline.add(randomVector(0, 15).add(center));\r\n\t\tspline.add(center);\r\n\t\tspline.add(randomVector(maxDim, 3 * maxDim).add(center));\r\n\r\n\t\treturn spline.computeVertices(steps);\r\n\t};\r\n\r\n\t//\r\n\t// Returns a random vector within the given radius limits\r\n\t//\r\n\tlet randomVector = function(minRadius, maxRadius) {\r\n\t\tvar angle = p.TWO_PI * Math.random();\r\n\t\tvar radius = minRadius + (maxRadius - minRadius) * p.randomGaussian();\r\n\t\treturn new toxi.geom.Vec2D(radius * Math.cos(angle), radius * Math.sin(angle));\r\n\t};\r\n\t// Creates and adds the canvas element\r\n\tfunction addCanvas(canvasWidth, canvasHeight) {\r\n\t\tvar referenceElement, maxCanvasWidth, canvas;\r\n\r\n\t\t// Calculate the canvas dimensions\r\n\t\treferenceElement = document.getElementById(\"widthRef\");\r\n\t\tmaxCanvasWidth = referenceElement.clientWidth - 1;\r\n\r\n\t\tif (canvasWidth > maxCanvasWidth) {\r\n\t\t\tcanvasHeight = maxCanvasWidth * canvasHeight / canvasWidth;\r\n\t\t\tcanvasWidth = maxCanvasWidth;\r\n\t\t}\r\n\r\n\t\t// Create the canvas\r\n\t\tcanvas = p.createCanvas(canvasWidth, canvasHeight);\r\n\r\n\t\t// Resize the canvas if necessary\r\n\t\tmaxCanvasWidth = referenceElement.clientWidth - 1;\r\n\r\n\t\tif (canvasWidth > maxCanvasWidth) {\r\n\t\t\tp.resizeCanvas(maxCanvasWidth, maxCanvasWidth * canvasHeight / canvasWidth, true);\r\n\t\t}\r\n\r\n\t\treturn canvas;\r\n\t}\r\n\r\n    p.windowResized = function(){\r\n        p.resizeCanvas(p.windowWidth,p.windowHeight)\r\n    }\r\n\t// Initial setup\r\n\tp.setup = function() {\r\n\t\t// Add the canvas element\r\n        //addCanvas(600, 400);\r\n        canvas = p.createCanvas(p.windowWidth,p.windowHeight);\r\n        canvas.position(0,0);\r\n        canvas.style('z-index','-1');\r\n\r\n\t\t// Calculate the trajectory positions for every particle\r\n\t\tpositions = calculateTrajectories(\"This is not a LOVE story\", 2 * p.width);\r\n\t};\r\n\r\n\t// Execute the sketch\r\n\tp.draw = function() {\r\n\t\t// Clean the canvas\r\n\t\tp.background(0, 100);\r\n\r\n\t\t// Paint the trajectories step by step\r\n\t\tif (step < positions[0].length) {\r\n\t\t\tp.noStroke();\r\n\t\t\tp.fill(0, 150, 200, 100);\r\n\r\n\t\t\t// Draw all the particles\r\n\t\t\tfor (var i = 0; i < positions.length; i++) {\r\n\t\t\t\tp.ellipse(positions[i][step].x, positions[i][step].y, 5, 5);\r\n\t\t\t}\r\n\t\t} else if (step > positions[0].length + 20) {\r\n\t\t\t// Stop the sketch\r\n\t\t\tp.noLoop();\r\n\t\t}\r\n\r\n\t\tstep++;\r\n\t};\r\n\r\n\t\r\n};"]},"metadata":{},"sourceType":"module"}