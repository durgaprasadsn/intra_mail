{"ast":null,"code":"export default function evolvingWordsSketch(p) {\n  // Global variables\n  var positions;\n  var step = 0; // Creates and adds the canvas element\n\n  function addCanvas(canvasWidth, canvasHeight) {\n    var referenceElement, maxCanvasWidth, canvas; // Calculate the canvas dimensions\n\n    referenceElement = document.getElementById(\"widthRef\");\n    maxCanvasWidth = referenceElement.clientWidth - 1;\n\n    if (canvasWidth > maxCanvasWidth) {\n      canvasHeight = maxCanvasWidth * canvasHeight / canvasWidth;\n      canvasWidth = maxCanvasWidth;\n    } // Create the canvas\n\n\n    canvas = p.createCanvas(canvasWidth, canvasHeight); // Resize the canvas if necessary\n\n    maxCanvasWidth = referenceElement.clientWidth - 1;\n\n    if (canvasWidth > maxCanvasWidth) {\n      p.resizeCanvas(maxCanvasWidth, maxCanvasWidth * canvasHeight / canvasWidth, true);\n    }\n\n    return canvas;\n  }\n\n  p.windowResized = function () {\n    p.resizeCanvas(p.windowWidth, p.windowHeight);\n  }; // Initial setup\n\n\n  p.setup = function () {\n    // Add the canvas element\n    //addCanvas(600, 400);\n    canvas = p.createCanvas(p.windowWidth, p.windowHeight);\n    canvas.position(0, 0);\n    canvas.style('z-index', '-1'); // Calculate the trajectory positions for every particle\n\n    positions = calculateTrajectories(\"This is not a LOVE story\", 2 * p.width);\n  }; // Execute the sketch\n\n\n  p.draw = function () {\n    // Clean the canvas\n    p.background(0, 100); // Paint the trajectories step by step\n\n    if (step < positions[0].length) {\n      p.noStroke();\n      p.fill(0, 150, 200, 100); // Draw all the particles\n\n      for (var i = 0; i < positions.length; i++) {\n        p.ellipse(positions[i][step].x, positions[i][step].y, 5, 5);\n      }\n    } else if (step > positions[0].length + 20) {\n      // Stop the sketch\n      p.noLoop();\n    }\n\n    step++;\n  }; //\n  // Calculates the particles trajectories\n  //\n\n\n  calculateTrajectories = function (text, nParticles) {\n    var words, limits, trajectories, nSteps, i; // Split the text into words\n\n    words = p.splitTokens(text, \" \"); // Calculate the words limits\n\n    limits = [];\n\n    for (i = 0; i < words.length; i++) {\n      limits[i] = wordLimits(words[i]);\n    } // Calculate the particle trajectories\n\n\n    trajectories = [];\n    nSteps = 80;\n\n    for (i = 0; i < nParticles; i++) {\n      trajectories[i] = trajectory(limits, nSteps);\n    }\n\n    return trajectories;\n  }; //\n  // Calculates the word limits\n  //\n\n\n  wordLimits = function (word) {\n    var textSize, limits, x, y, dx, dy, px, py, pixelDensity, pixelDensitySq, isLimit; // Paint the background\n\n    p.background(0); // Paint the text\n\n    textSize = 0.25 * p.width;\n    p.push();\n    p.textFont(\"Helvetica\");\n    p.textAlign(p.CENTER);\n    p.textSize(textSize);\n    p.textStyle(p.BOLD);\n    p.noStroke();\n    p.fill(255);\n    p.text(word, 0.5 * p.width, 0.5 * p.height + 0.25 * textSize);\n    p.pop(); // Calculate the limits\n\n    limits = [];\n    pixelDensity = p.displayDensity();\n    pixelDensitySq = pixelDensity * pixelDensity;\n    p.loadPixels();\n\n    for (y = 0; y < p.height; y++) {\n      for (x = 0; x < p.width; x++) {\n        isLimit = false;\n\n        if (p.pixels[4 * (x * pixelDensity + y * p.width * pixelDensitySq)] === 255) {\n          // Check the nearby pixels for a color change\n          for (dx = -1; dx <= 1; dx++) {\n            for (dy = -1; dy <= 1; dy++) {\n              // Don't calculate more if we already know that it's\n              // a limit\n              if (!isLimit) {\n                px = x + dx;\n                py = y + dy;\n\n                if (px >= 0 && px < p.width && py >= 0 && py < p.height) {\n                  if (p.pixels[4 * (px * pixelDensity + py * p.width * pixelDensitySq)] !== 255) {\n                    isLimit = true;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (isLimit) {\n          limits.push(new toxi.geom.Vec2D(x, y));\n        }\n      }\n    }\n\n    p.updatePixels(); // Clean the canvas\n\n    p.background(0);\n    return limits;\n  }; //\n  // Calculates the particle trajectory\n  //\n\n\n  trajectory = function (limits, steps) {\n    var positionInWords, i, spline, center; // Calculate the particle position in the different words\n\n    positionInWords = [];\n\n    for (i = 0; i < limits.length; i++) {\n      positionInWords[i] = limits[i][Math.floor(limits[i].length * Math.random())];\n    } // Add the spline points\n\n\n    spline = new toxi.geom.Spline2D();\n    spline.setTightness(0.2);\n    minDim = Math.min(p.width, p.height);\n    maxDim = Math.max(p.width, p.height);\n    center = new toxi.geom.Vec2D(0.5 * p.width, 0.5 * p.height);\n\n    for (i = 0; i < positionInWords.length - 1; i++) {\n      spline.add(positionInWords[i]);\n      spline.add(randomVector(0, 15).add(center));\n      spline.add(randomVector(0, 0.2 * minDim).add(positionInWords[i + 1]));\n      spline.add(randomVector(0, 0.02 * minDim).add(positionInWords[i + 1]));\n    }\n\n    spline.add(positionInWords[positionInWords.length - 1]);\n    spline.add(randomVector(0, 15).add(center));\n    spline.add(center);\n    spline.add(randomVector(maxDim, 3 * maxDim).add(center));\n    return spline.computeVertices(steps);\n  }; //\n  // Returns a random vector within the given radius limits\n  //\n\n\n  randomVector = function (minRadius, maxRadius) {\n    var angle = p.TWO_PI * Math.random();\n    var radius = minRadius + (maxRadius - minRadius) * p.randomGaussian();\n    return new toxi.geom.Vec2D(radius * Math.cos(angle), radius * Math.sin(angle));\n  };\n}\n;","map":{"version":3,"sources":["C:/Users/GAURAV C G/Desktop/Work/intra_mail/src/sketches/evolvingWords.js"],"names":["evolvingWordsSketch","p","positions","step","addCanvas","canvasWidth","canvasHeight","referenceElement","maxCanvasWidth","canvas","document","getElementById","clientWidth","createCanvas","resizeCanvas","windowResized","windowWidth","windowHeight","setup","position","style","calculateTrajectories","width","draw","background","length","noStroke","fill","i","ellipse","x","y","noLoop","text","nParticles","words","limits","trajectories","nSteps","splitTokens","wordLimits","trajectory","word","textSize","dx","dy","px","py","pixelDensity","pixelDensitySq","isLimit","push","textFont","textAlign","CENTER","textStyle","BOLD","height","pop","displayDensity","loadPixels","pixels","toxi","geom","Vec2D","updatePixels","steps","positionInWords","spline","center","Math","floor","random","Spline2D","setTightness","minDim","min","maxDim","max","add","randomVector","computeVertices","minRadius","maxRadius","angle","TWO_PI","radius","randomGaussian","cos","sin"],"mappings":"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","sourcesContent":["export default function evolvingWordsSketch(p){\r\n\t// Global variables\r\n\tvar positions;\r\n\tvar step = 0;\r\n\r\n\t// Creates and adds the canvas element\r\n\tfunction addCanvas(canvasWidth, canvasHeight) {\r\n\t\tvar referenceElement, maxCanvasWidth, canvas;\r\n\r\n\t\t// Calculate the canvas dimensions\r\n\t\treferenceElement = document.getElementById(\"widthRef\");\r\n\t\tmaxCanvasWidth = referenceElement.clientWidth - 1;\r\n\r\n\t\tif (canvasWidth > maxCanvasWidth) {\r\n\t\t\tcanvasHeight = maxCanvasWidth * canvasHeight / canvasWidth;\r\n\t\t\tcanvasWidth = maxCanvasWidth;\r\n\t\t}\r\n\r\n\t\t// Create the canvas\r\n\t\tcanvas = p.createCanvas(canvasWidth, canvasHeight);\r\n\r\n\t\t// Resize the canvas if necessary\r\n\t\tmaxCanvasWidth = referenceElement.clientWidth - 1;\r\n\r\n\t\tif (canvasWidth > maxCanvasWidth) {\r\n\t\t\tp.resizeCanvas(maxCanvasWidth, maxCanvasWidth * canvasHeight / canvasWidth, true);\r\n\t\t}\r\n\r\n\t\treturn canvas;\r\n\t}\r\n\r\n    p.windowResized = function(){\r\n        p.resizeCanvas(p.windowWidth,p.windowHeight)\r\n    }\r\n\t// Initial setup\r\n\tp.setup = function() {\r\n\t\t// Add the canvas element\r\n        //addCanvas(600, 400);\r\n        canvas = p.createCanvas(p.windowWidth,p.windowHeight);\r\n        canvas.position(0,0);\r\n        canvas.style('z-index','-1');\r\n\r\n\t\t// Calculate the trajectory positions for every particle\r\n\t\tpositions = calculateTrajectories(\"This is not a LOVE story\", 2 * p.width);\r\n\t};\r\n\r\n\t// Execute the sketch\r\n\tp.draw = function() {\r\n\t\t// Clean the canvas\r\n\t\tp.background(0, 100);\r\n\r\n\t\t// Paint the trajectories step by step\r\n\t\tif (step < positions[0].length) {\r\n\t\t\tp.noStroke();\r\n\t\t\tp.fill(0, 150, 200, 100);\r\n\r\n\t\t\t// Draw all the particles\r\n\t\t\tfor (var i = 0; i < positions.length; i++) {\r\n\t\t\t\tp.ellipse(positions[i][step].x, positions[i][step].y, 5, 5);\r\n\t\t\t}\r\n\t\t} else if (step > positions[0].length + 20) {\r\n\t\t\t// Stop the sketch\r\n\t\t\tp.noLoop();\r\n\t\t}\r\n\r\n\t\tstep++;\r\n\t};\r\n\r\n\t//\r\n\t// Calculates the particles trajectories\r\n\t//\r\n\tcalculateTrajectories = function(text, nParticles) {\r\n\t\tvar words, limits, trajectories, nSteps, i;\r\n\r\n\t\t// Split the text into words\r\n\t\twords = p.splitTokens(text, \" \");\r\n\r\n\t\t// Calculate the words limits\r\n\t\tlimits = [];\r\n\r\n\t\tfor (i = 0; i < words.length; i++) {\r\n\t\t\tlimits[i] = wordLimits(words[i]);\r\n\t\t}\r\n\r\n\t\t// Calculate the particle trajectories\r\n\t\ttrajectories = [];\r\n\t\tnSteps = 80;\r\n\r\n\t\tfor (i = 0; i < nParticles; i++) {\r\n\t\t\ttrajectories[i] = trajectory(limits, nSteps);\r\n\t\t}\r\n\r\n\t\treturn trajectories;\r\n\t};\r\n\r\n\t//\r\n\t// Calculates the word limits\r\n\t//\r\n\twordLimits = function(word) {\r\n\t\tvar textSize, limits, x, y, dx, dy, px, py, pixelDensity, pixelDensitySq, isLimit;\r\n\r\n\t\t// Paint the background\r\n\t\tp.background(0);\r\n\r\n\t\t// Paint the text\r\n\t\ttextSize = 0.25 * p.width;\r\n\t\tp.push();\r\n\t\tp.textFont(\"Helvetica\");\r\n\t\tp.textAlign(p.CENTER);\r\n\t\tp.textSize(textSize);\r\n\t\tp.textStyle(p.BOLD);\r\n\t\tp.noStroke();\r\n\t\tp.fill(255);\r\n\t\tp.text(word, 0.5 * p.width, 0.5 * p.height + 0.25 * textSize);\r\n\t\tp.pop();\r\n\r\n\t\t// Calculate the limits\r\n\t\tlimits = [];\r\n\t\tpixelDensity = p.displayDensity();\r\n\t\tpixelDensitySq = pixelDensity * pixelDensity;\r\n\r\n\t\tp.loadPixels();\r\n\r\n\t\tfor (y = 0; y < p.height; y++) {\r\n\t\t\tfor (x = 0; x < p.width; x++) {\r\n\t\t\t\tisLimit = false;\r\n\r\n\t\t\t\tif (p.pixels[4 * (x * pixelDensity + y * p.width * pixelDensitySq)] === 255) {\r\n\t\t\t\t\t// Check the nearby pixels for a color change\r\n\t\t\t\t\tfor (dx = -1; dx <= 1; dx++) {\r\n\t\t\t\t\t\tfor (dy = -1; dy <= 1; dy++) {\r\n\t\t\t\t\t\t\t// Don't calculate more if we already know that it's\r\n\t\t\t\t\t\t\t// a limit\r\n\t\t\t\t\t\t\tif (!isLimit) {\r\n\t\t\t\t\t\t\t\tpx = x + dx;\r\n\t\t\t\t\t\t\t\tpy = y + dy;\r\n\r\n\t\t\t\t\t\t\t\tif (px >= 0 && px < p.width && py >= 0 && py < p.height) {\r\n\t\t\t\t\t\t\t\t\tif (p.pixels[4 * (px * pixelDensity + py * p.width * pixelDensitySq)] !== 255) {\r\n\t\t\t\t\t\t\t\t\t\tisLimit = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isLimit) {\r\n\t\t\t\t\tlimits.push(new toxi.geom.Vec2D(x, y));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tp.updatePixels();\r\n\r\n\t\t// Clean the canvas\r\n\t\tp.background(0);\r\n\r\n\t\treturn limits;\r\n\t};\r\n\r\n\t//\r\n\t// Calculates the particle trajectory\r\n\t//\r\n\ttrajectory = function(limits, steps) {\r\n\t\tvar positionInWords, i, spline, center;\r\n\r\n\t\t// Calculate the particle position in the different words\r\n\t\tpositionInWords = [];\r\n\r\n\t\tfor (i = 0; i < limits.length; i++) {\r\n\t\t\tpositionInWords[i] = limits[i][Math.floor(limits[i].length * Math.random())];\r\n\t\t}\r\n\r\n\t\t// Add the spline points\r\n\t\tspline = new toxi.geom.Spline2D();\r\n\t\tspline.setTightness(0.2);\r\n\t\tminDim = Math.min(p.width, p.height);\r\n\t\tmaxDim = Math.max(p.width, p.height);\r\n\t\tcenter = new toxi.geom.Vec2D(0.5 * p.width, 0.5 * p.height);\r\n\r\n\t\tfor (i = 0; i < positionInWords.length - 1; i++) {\r\n\t\t\tspline.add(positionInWords[i]);\r\n\t\t\tspline.add(randomVector(0, 15).add(center));\r\n\t\t\tspline.add(randomVector(0, 0.2 * minDim).add(positionInWords[i + 1]));\r\n\t\t\tspline.add(randomVector(0, 0.02 * minDim).add(positionInWords[i + 1]));\r\n\t\t}\r\n\r\n\t\tspline.add(positionInWords[positionInWords.length - 1]);\r\n\t\tspline.add(randomVector(0, 15).add(center));\r\n\t\tspline.add(center);\r\n\t\tspline.add(randomVector(maxDim, 3 * maxDim).add(center));\r\n\r\n\t\treturn spline.computeVertices(steps);\r\n\t};\r\n\r\n\t//\r\n\t// Returns a random vector within the given radius limits\r\n\t//\r\n\trandomVector = function(minRadius, maxRadius) {\r\n\t\tvar angle = p.TWO_PI * Math.random();\r\n\t\tvar radius = minRadius + (maxRadius - minRadius) * p.randomGaussian();\r\n\t\treturn new toxi.geom.Vec2D(radius * Math.cos(angle), radius * Math.sin(angle));\r\n\t};\r\n};"]},"metadata":{},"sourceType":"module"}